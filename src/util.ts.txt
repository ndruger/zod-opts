

import { z } from "zod";

import {
  Option,
  Options,
  ParseResultError,
  ParseResultHelp,
  ParseResultVersion,
  PositionalArg,
  PositionalArgs,
} from "./type";

const IdRegexStr = "^[A-Za-z0-9_]+[A-Za-z0-9_-]*$";
const IdSchema = z.string().regex(new RegExp(IdRegexStr)).max(256);
const OptionAliasRegexStr = "^[A-Za-z0-9_]+$";
const OptionAliasSchema = z.string().regex(new RegExp(OptionAliasRegexStr)).max(10);

export function uniq<T>(array: T[]): T[] {
  return [...new Set(array)];
}

export function errorExit(
  parseResult: ParseResultError | ParseResultHelp | ParseResultVersion,
  version = "none"
): never {
  const { type, help, exitCode } = parseResult;
  switch (type) {
    case "help":
      console.log(help);
      break;
    case "version":
      console.log(version);
      break;
    default:
      console.error(`${parseResult.error.message}\n`);
      console.error(help);
  }
  process.exit(exitCode);
}

function validateParamOption(name: string, { alias }: Option): void {
  if (!IdSchema.safeParse(name).success) {
    throw new Error(`Invalid option name. Supported pattern is /${IdRegexStr}/: ${name}`);
  }
  if (alias !== undefined && !OptionAliasSchema.safeParse(alias).success) {
    throw new Error(`Invalid option alias. Supported pattern is /${OptionAliasRegexStr}/: ${alias}`);
  }
}

function validateParamPositionalArg({ name }: PositionalArg): void {
  if (!IdSchema.safeParse(name).success) {
    throw new Error(`Invalid positional option name. Supported pattern is /${IdRegexStr}/: ${name}`);
  }
}

function getDuplicatedInputs(array: string[]): string[] {
  return array.filter((e, i, a) => a.indexOf(e) !== i);
}

function checkIfOptionNamesDuplicated(options: Options = {}): void {
  const duplicatedName = getDuplicatedInputs(Object.keys(options));
  if (duplicatedName.length !== 0) {
    throw new Error(`Duplicated option name: ${duplicatedName.join(", ")}`);
  }
}

function checkIfPositionalOptionNamesDuplicated(positionalArgs: PositionalArgs): void {
  const duplicatedName = getDuplicatedInputs(positionalArgs.map((option) => option.name));
  if (duplicatedName.length !== 0) {
    throw new Error(`Duplicated positional option name: ${duplicatedName.join(", ")}`);
  }
}

function checkIfOptNameUsedWithPositionalOption(options: Options, positionalArgs: PositionalArgs): void {
  Object.keys(options).forEach((optionName) => {
    if (positionalArgs.some((option) => option.name === optionName)) {
      throw new Error(`Duplicated option name with positional option name: ${optionName}`);
    }
  });
}

export function validateParamOptionsAndPositionalArgs(options: Options, positionalArgs: PositionalArgs): void {
  Object.entries(options).forEach(([optionName, option]) => {
    validateParamOption(optionName, option);
  });
  checkIfOptionNamesDuplicated(options);
  positionalArgs.forEach(validateParamPositionalArg);
  checkIfPositionalOptionNamesDuplicated(positionalArgs);
  checkIfOptNameUsedWithPositionalOption(options, positionalArgs);
}

export function assertNever(value: never): never {
  throw new Error(`Unreachable code reached: ${JSON.stringify(value)}`);
}